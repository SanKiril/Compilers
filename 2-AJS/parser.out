Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    BOOLEAN
    CHAR
    CHARACTER
    COMMENT
    COMPARATOR
    ELSE
    FL
    FLOAT
    FUNCTION
    IF
    INT
    LET
    NULL
    RETURN
    STRING_EXPLICIT
    STRING_IMPLICIT
    TR
    TYPE
    WHILE

Grammar

Rule 0     S' -> file
Rule 1     file -> expression
Rule 2     file -> empty
Rule 3     expression -> expression ARITHMETIC term
Rule 4     expression -> term
Rule 5     term -> term ARITHMETIC factor
Rule 6     term -> factor
Rule 7     factor -> INTEGER
Rule 8     factor -> REAL
Rule 9     factor -> ( expression )
Rule 10    empty -> <empty>

Terminals, with rules where they appear

(                    : 9
)                    : 9
ARITHMETIC           : 3 5
BOOL                 : 
BOOLEAN              : 
CHAR                 : 
CHARACTER            : 
COMMENT              : 
COMPARATOR           : 
ELSE                 : 
FL                   : 
FLOAT                : 
FUNCTION             : 
IF                   : 
INT                  : 
INTEGER              : 7
LET                  : 
NULL                 : 
REAL                 : 8
RETURN               : 
STRING_EXPLICIT      : 
STRING_IMPLICIT      : 
TR                   : 
TYPE                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

empty                : 2
expression           : 1 3 9
factor               : 5 6
file                 : 0
term                 : 3 4 5

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . expression
    (2) file -> . empty
    (3) expression -> . expression ARITHMETIC term
    (4) expression -> . term
    (10) empty -> .
    (5) term -> . term ARITHMETIC factor
    (6) term -> . factor
    (7) factor -> . INTEGER
    (8) factor -> . REAL
    (9) factor -> . ( expression )

    $end            reduce using rule 10 (empty -> .)
    INTEGER         shift and go to state 6
    REAL            shift and go to state 7
    (               shift and go to state 8

    file                           shift and go to state 1
    expression                     shift and go to state 2
    empty                          shift and go to state 3
    term                           shift and go to state 4
    factor                         shift and go to state 5

state 1

    (0) S' -> file .



state 2

    (1) file -> expression .
    (3) expression -> expression . ARITHMETIC term

    $end            reduce using rule 1 (file -> expression .)
    ARITHMETIC      shift and go to state 9


state 3

    (2) file -> empty .

    $end            reduce using rule 2 (file -> empty .)


state 4

    (4) expression -> term .
    (5) term -> term . ARITHMETIC factor

  ! shift/reduce conflict for ARITHMETIC resolved as shift
    $end            reduce using rule 4 (expression -> term .)
    )               reduce using rule 4 (expression -> term .)
    ARITHMETIC      shift and go to state 10

  ! ARITHMETIC      [ reduce using rule 4 (expression -> term .) ]


state 5

    (6) term -> factor .

    ARITHMETIC      reduce using rule 6 (term -> factor .)
    $end            reduce using rule 6 (term -> factor .)
    )               reduce using rule 6 (term -> factor .)


state 6

    (7) factor -> INTEGER .

    ARITHMETIC      reduce using rule 7 (factor -> INTEGER .)
    $end            reduce using rule 7 (factor -> INTEGER .)
    )               reduce using rule 7 (factor -> INTEGER .)


state 7

    (8) factor -> REAL .

    ARITHMETIC      reduce using rule 8 (factor -> REAL .)
    $end            reduce using rule 8 (factor -> REAL .)
    )               reduce using rule 8 (factor -> REAL .)


state 8

    (9) factor -> ( . expression )
    (3) expression -> . expression ARITHMETIC term
    (4) expression -> . term
    (5) term -> . term ARITHMETIC factor
    (6) term -> . factor
    (7) factor -> . INTEGER
    (8) factor -> . REAL
    (9) factor -> . ( expression )

    INTEGER         shift and go to state 6
    REAL            shift and go to state 7
    (               shift and go to state 8

    expression                     shift and go to state 11
    term                           shift and go to state 4
    factor                         shift and go to state 5

state 9

    (3) expression -> expression ARITHMETIC . term
    (5) term -> . term ARITHMETIC factor
    (6) term -> . factor
    (7) factor -> . INTEGER
    (8) factor -> . REAL
    (9) factor -> . ( expression )

    INTEGER         shift and go to state 6
    REAL            shift and go to state 7
    (               shift and go to state 8

    term                           shift and go to state 12
    factor                         shift and go to state 5

state 10

    (5) term -> term ARITHMETIC . factor
    (7) factor -> . INTEGER
    (8) factor -> . REAL
    (9) factor -> . ( expression )

    INTEGER         shift and go to state 6
    REAL            shift and go to state 7
    (               shift and go to state 8

    factor                         shift and go to state 13

state 11

    (9) factor -> ( expression . )
    (3) expression -> expression . ARITHMETIC term

    )               shift and go to state 14
    ARITHMETIC      shift and go to state 9


state 12

    (3) expression -> expression ARITHMETIC term .
    (5) term -> term . ARITHMETIC factor

  ! shift/reduce conflict for ARITHMETIC resolved as shift
    $end            reduce using rule 3 (expression -> expression ARITHMETIC term .)
    )               reduce using rule 3 (expression -> expression ARITHMETIC term .)
    ARITHMETIC      shift and go to state 10

  ! ARITHMETIC      [ reduce using rule 3 (expression -> expression ARITHMETIC term .) ]


state 13

    (5) term -> term ARITHMETIC factor .

    ARITHMETIC      reduce using rule 5 (term -> term ARITHMETIC factor .)
    $end            reduce using rule 5 (term -> term ARITHMETIC factor .)
    )               reduce using rule 5 (term -> term ARITHMETIC factor .)


state 14

    (9) factor -> ( expression ) .

    ARITHMETIC      reduce using rule 9 (factor -> ( expression ) .)
    $end            reduce using rule 9 (factor -> ( expression ) .)
    )               reduce using rule 9 (factor -> ( expression ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ARITHMETIC in state 4 resolved as shift
WARNING: shift/reduce conflict for ARITHMETIC in state 12 resolved as shift
