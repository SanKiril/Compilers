Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> file
Rule 1     file -> statement file
Rule 2     file -> block file
Rule 3     file -> empty
Rule 4     statement -> declaration ;
Rule 5     statement -> assignment ;
Rule 6     statement -> definition ;
Rule 7     statement -> expression ;
Rule 8     block -> simple_block
Rule 9     block -> function
Rule 10    simple_block -> if_conditional
Rule 11    simple_block -> while_loop
Rule 12    block_body -> { block_body_code }
Rule 13    block_body_code -> statement block_body_code
Rule 14    block_body_code -> simple_block block_body_code
Rule 15    block_body_code -> statement
Rule 16    block_body_code -> simple_block
Rule 17    declaration -> LET declaration_content
Rule 18    declaration_content -> item , declaration_content
Rule 19    declaration_content -> item
Rule 20    item -> STRING_IMPLICIT : STRING_IMPLICIT
Rule 21    item -> STRING_IMPLICIT
Rule 22    assignment -> declaration ASSIGN expression
Rule 23    assignment -> STRING_IMPLICIT ASSIGN expression
Rule 24    definition -> TYPE STRING_IMPLICIT ASSIGN object
Rule 25    object -> { object_content }
Rule 26    object_content -> object_item , object_content
Rule 27    object_content -> object_item
Rule 28    object_content -> empty
Rule 29    object_item -> key : basic_type
Rule 30    object_item -> key : expression
Rule 31    key -> STRING_EXPLICIT
Rule 32    key -> STRING_IMPLICIT
Rule 33    type -> basic_type
Rule 34    type -> STRING_IMPLICIT
Rule 35    basic_type -> INT
Rule 36    basic_type -> FLOAT
Rule 37    basic_type -> CHARACTER
Rule 38    basic_type -> BOOLEAN
Rule 39    if_conditional -> IF condition block_body
Rule 40    if_conditional -> IF condition block_body ELSE block_body
Rule 41    while_loop -> WHILE condition block_body
Rule 42    condition -> ( expression )
Rule 43    function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; }
Rule 44    argument_list -> argument_list_nonempty
Rule 45    argument_list -> empty
Rule 46    argument_list_nonempty -> STRING_IMPLICIT : type , argument_list_nonempty
Rule 47    argument_list_nonempty -> STRING_IMPLICIT : type
Rule 48    expression -> ( expression )
Rule 49    expression -> expression binary_operator expression
Rule 50    expression -> unary_operator expression
Rule 51    expression -> INTEGER
Rule 52    expression -> REAL
Rule 53    expression -> CHAR
Rule 54    expression -> TR
Rule 55    expression -> FL
Rule 56    expression -> NULL
Rule 57    expression -> STRING_IMPLICIT
Rule 58    expression -> function_call
Rule 59    expression -> object_call
Rule 60    expression -> object
Rule 61    binary_operator -> PLUS
Rule 62    binary_operator -> MINUS
Rule 63    binary_operator -> TIMES
Rule 64    binary_operator -> DIVIDE
Rule 65    binary_operator -> AND
Rule 66    binary_operator -> OR
Rule 67    binary_operator -> LT
Rule 68    binary_operator -> LE
Rule 69    binary_operator -> EQ
Rule 70    binary_operator -> GE
Rule 71    binary_operator -> GT
Rule 72    unary_operator -> PLUS
Rule 73    unary_operator -> MINUS
Rule 74    unary_operator -> NOT
Rule 75    function_call -> STRING_IMPLICIT ( function_call_list )
Rule 76    function_call_list -> function_call_list_nonempty
Rule 77    function_call_list -> empty
Rule 78    function_call_list_nonempty -> expression , function_call_list_nonempty
Rule 79    function_call_list_nonempty -> expression
Rule 80    object_call -> STRING_IMPLICIT object_attribute_list
Rule 81    object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list
Rule 82    object_attribute_list -> . STRING_IMPLICIT object_attribute_list
Rule 83    object_attribute_list -> [ STRING_EXPLICIT ]
Rule 84    object_attribute_list -> . STRING_IMPLICIT
Rule 85    empty -> <empty>

Terminals, with rules where they appear

(                    : 42 43 48 75
)                    : 42 43 48 75
,                    : 18 26 46 78
.                    : 82 84
:                    : 20 29 30 43 46 47
;                    : 4 5 6 7 43
AND                  : 65
ASSIGN               : 22 23 24
BOOLEAN              : 38
CHAR                 : 53
CHARACTER            : 37
DIVIDE               : 64
ELSE                 : 40
EQ                   : 69
FL                   : 55
FLOAT                : 36
FUNCTION             : 43
GE                   : 70
GT                   : 71
IF                   : 39 40
INT                  : 35
INTEGER              : 51
LE                   : 68
LET                  : 17
LT                   : 67
MINUS                : 62 73
NOT                  : 74
NULL                 : 56
OR                   : 66
PLUS                 : 61 72
REAL                 : 52
RETURN               : 43
STRING_EXPLICIT      : 31 81 83
STRING_IMPLICIT      : 20 20 21 23 24 32 34 43 46 47 57 75 80 82 84
TIMES                : 63
TR                   : 54
TYPE                 : 24
WHILE                : 41
[                    : 81 83
]                    : 81 83
error                : 
{                    : 12 25 43
}                    : 12 25 43

Nonterminals, with rules where they appear

argument_list        : 43
argument_list_nonempty : 44 46
assignment           : 5
basic_type           : 29 33
binary_operator      : 49
block                : 2
block_body           : 39 40 40 41
block_body_code      : 12 13 14 43
condition            : 39 40 41
declaration          : 4 22
declaration_content  : 17 18
definition           : 6
empty                : 3 28 45 77
expression           : 7 22 23 30 42 43 48 49 49 50 78 79
file                 : 1 2 0
function             : 9
function_call        : 58
function_call_list   : 75
function_call_list_nonempty : 76 78
if_conditional       : 10
item                 : 18 19
key                  : 29 30
object               : 24 60
object_attribute_list : 80 81 82
object_call          : 59
object_content       : 25 26
object_item          : 26 27
simple_block         : 8 14 16
statement            : 1 13 15
type                 : 43 46 47
unary_operator       : 50
while_loop           : 11

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . statement file
    (2) file -> . block file
    (3) file -> . empty
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (8) block -> . simple_block
    (9) block -> . function
    (85) empty -> .
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (43) function -> . FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; }
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body

    $end            reduce using rule 85 (empty -> .)
    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    FUNCTION        shift and go to state 27
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28
    IF              shift and go to state 32
    WHILE           shift and go to state 33

    file                           shift and go to state 1
    statement                      shift and go to state 2
    block                          shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    expression                     shift and go to state 8
    simple_block                   shift and go to state 9
    function                       shift and go to state 10
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26

state 1

    (0) S' -> file .



state 2

    (1) file -> statement . file
    (1) file -> . statement file
    (2) file -> . block file
    (3) file -> . empty
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (8) block -> . simple_block
    (9) block -> . function
    (85) empty -> .
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (43) function -> . FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; }
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body

    $end            reduce using rule 85 (empty -> .)
    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    FUNCTION        shift and go to state 27
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28
    IF              shift and go to state 32
    WHILE           shift and go to state 33

    statement                      shift and go to state 2
    file                           shift and go to state 34
    block                          shift and go to state 3
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    expression                     shift and go to state 8
    simple_block                   shift and go to state 9
    function                       shift and go to state 10
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26

state 3

    (2) file -> block . file
    (1) file -> . statement file
    (2) file -> . block file
    (3) file -> . empty
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (8) block -> . simple_block
    (9) block -> . function
    (85) empty -> .
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (43) function -> . FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; }
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body

    $end            reduce using rule 85 (empty -> .)
    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    FUNCTION        shift and go to state 27
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28
    IF              shift and go to state 32
    WHILE           shift and go to state 33

    block                          shift and go to state 3
    file                           shift and go to state 35
    statement                      shift and go to state 2
    empty                          shift and go to state 4
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    expression                     shift and go to state 8
    simple_block                   shift and go to state 9
    function                       shift and go to state 10
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26

state 4

    (3) file -> empty .

    $end            reduce using rule 3 (file -> empty .)


state 5

    (4) statement -> declaration . ;
    (22) assignment -> declaration . ASSIGN expression

    ;               shift and go to state 36
    ASSIGN          shift and go to state 37


state 6

    (5) statement -> assignment . ;

    ;               shift and go to state 38


state 7

    (6) statement -> definition . ;

    ;               shift and go to state 39


state 8

    (7) statement -> expression . ;
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ;               shift and go to state 40
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 9

    (8) block -> simple_block .

    LET             reduce using rule 8 (block -> simple_block .)
    STRING_IMPLICIT reduce using rule 8 (block -> simple_block .)
    TYPE            reduce using rule 8 (block -> simple_block .)
    (               reduce using rule 8 (block -> simple_block .)
    INTEGER         reduce using rule 8 (block -> simple_block .)
    REAL            reduce using rule 8 (block -> simple_block .)
    CHAR            reduce using rule 8 (block -> simple_block .)
    TR              reduce using rule 8 (block -> simple_block .)
    FL              reduce using rule 8 (block -> simple_block .)
    NULL            reduce using rule 8 (block -> simple_block .)
    FUNCTION        reduce using rule 8 (block -> simple_block .)
    PLUS            reduce using rule 8 (block -> simple_block .)
    MINUS           reduce using rule 8 (block -> simple_block .)
    NOT             reduce using rule 8 (block -> simple_block .)
    {               reduce using rule 8 (block -> simple_block .)
    IF              reduce using rule 8 (block -> simple_block .)
    WHILE           reduce using rule 8 (block -> simple_block .)
    $end            reduce using rule 8 (block -> simple_block .)


state 10

    (9) block -> function .

    LET             reduce using rule 9 (block -> function .)
    STRING_IMPLICIT reduce using rule 9 (block -> function .)
    TYPE            reduce using rule 9 (block -> function .)
    (               reduce using rule 9 (block -> function .)
    INTEGER         reduce using rule 9 (block -> function .)
    REAL            reduce using rule 9 (block -> function .)
    CHAR            reduce using rule 9 (block -> function .)
    TR              reduce using rule 9 (block -> function .)
    FL              reduce using rule 9 (block -> function .)
    NULL            reduce using rule 9 (block -> function .)
    FUNCTION        reduce using rule 9 (block -> function .)
    PLUS            reduce using rule 9 (block -> function .)
    MINUS           reduce using rule 9 (block -> function .)
    NOT             reduce using rule 9 (block -> function .)
    {               reduce using rule 9 (block -> function .)
    IF              reduce using rule 9 (block -> function .)
    WHILE           reduce using rule 9 (block -> function .)
    $end            reduce using rule 9 (block -> function .)


state 11

    (17) declaration -> LET . declaration_content
    (18) declaration_content -> . item , declaration_content
    (19) declaration_content -> . item
    (20) item -> . STRING_IMPLICIT : STRING_IMPLICIT
    (21) item -> . STRING_IMPLICIT

    STRING_IMPLICIT shift and go to state 55

    declaration_content            shift and go to state 53
    item                           shift and go to state 54

state 12

    (23) assignment -> STRING_IMPLICIT . ASSIGN expression
    (57) expression -> STRING_IMPLICIT .
    (75) function_call -> STRING_IMPLICIT . ( function_call_list )
    (80) object_call -> STRING_IMPLICIT . object_attribute_list
    (81) object_attribute_list -> . [ STRING_EXPLICIT ] object_attribute_list
    (82) object_attribute_list -> . . STRING_IMPLICIT object_attribute_list
    (83) object_attribute_list -> . [ STRING_EXPLICIT ]
    (84) object_attribute_list -> . . STRING_IMPLICIT

    ASSIGN          shift and go to state 56
    ;               reduce using rule 57 (expression -> STRING_IMPLICIT .)
    PLUS            reduce using rule 57 (expression -> STRING_IMPLICIT .)
    MINUS           reduce using rule 57 (expression -> STRING_IMPLICIT .)
    TIMES           reduce using rule 57 (expression -> STRING_IMPLICIT .)
    DIVIDE          reduce using rule 57 (expression -> STRING_IMPLICIT .)
    AND             reduce using rule 57 (expression -> STRING_IMPLICIT .)
    OR              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    LT              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    LE              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    EQ              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    GE              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    GT              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    (               shift and go to state 57
    [               shift and go to state 59
    .               shift and go to state 60

    object_attribute_list          shift and go to state 58

state 13

    (24) definition -> TYPE . STRING_IMPLICIT ASSIGN object

    STRING_IMPLICIT shift and go to state 61


state 14

    (60) expression -> object .

    ;               reduce using rule 60 (expression -> object .)
    PLUS            reduce using rule 60 (expression -> object .)
    MINUS           reduce using rule 60 (expression -> object .)
    TIMES           reduce using rule 60 (expression -> object .)
    DIVIDE          reduce using rule 60 (expression -> object .)
    AND             reduce using rule 60 (expression -> object .)
    OR              reduce using rule 60 (expression -> object .)
    LT              reduce using rule 60 (expression -> object .)
    LE              reduce using rule 60 (expression -> object .)
    EQ              reduce using rule 60 (expression -> object .)
    GE              reduce using rule 60 (expression -> object .)
    GT              reduce using rule 60 (expression -> object .)
    )               reduce using rule 60 (expression -> object .)
    ,               reduce using rule 60 (expression -> object .)
    }               reduce using rule 60 (expression -> object .)


state 15

    (48) expression -> ( . expression )
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 62
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 16

    (50) expression -> unary_operator . expression
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    unary_operator                 shift and go to state 16
    expression                     shift and go to state 64
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 17

    (51) expression -> INTEGER .

    ;               reduce using rule 51 (expression -> INTEGER .)
    PLUS            reduce using rule 51 (expression -> INTEGER .)
    MINUS           reduce using rule 51 (expression -> INTEGER .)
    TIMES           reduce using rule 51 (expression -> INTEGER .)
    DIVIDE          reduce using rule 51 (expression -> INTEGER .)
    AND             reduce using rule 51 (expression -> INTEGER .)
    OR              reduce using rule 51 (expression -> INTEGER .)
    LT              reduce using rule 51 (expression -> INTEGER .)
    LE              reduce using rule 51 (expression -> INTEGER .)
    EQ              reduce using rule 51 (expression -> INTEGER .)
    GE              reduce using rule 51 (expression -> INTEGER .)
    GT              reduce using rule 51 (expression -> INTEGER .)
    )               reduce using rule 51 (expression -> INTEGER .)
    ,               reduce using rule 51 (expression -> INTEGER .)
    }               reduce using rule 51 (expression -> INTEGER .)


state 18

    (52) expression -> REAL .

    ;               reduce using rule 52 (expression -> REAL .)
    PLUS            reduce using rule 52 (expression -> REAL .)
    MINUS           reduce using rule 52 (expression -> REAL .)
    TIMES           reduce using rule 52 (expression -> REAL .)
    DIVIDE          reduce using rule 52 (expression -> REAL .)
    AND             reduce using rule 52 (expression -> REAL .)
    OR              reduce using rule 52 (expression -> REAL .)
    LT              reduce using rule 52 (expression -> REAL .)
    LE              reduce using rule 52 (expression -> REAL .)
    EQ              reduce using rule 52 (expression -> REAL .)
    GE              reduce using rule 52 (expression -> REAL .)
    GT              reduce using rule 52 (expression -> REAL .)
    )               reduce using rule 52 (expression -> REAL .)
    ,               reduce using rule 52 (expression -> REAL .)
    }               reduce using rule 52 (expression -> REAL .)


state 19

    (53) expression -> CHAR .

    ;               reduce using rule 53 (expression -> CHAR .)
    PLUS            reduce using rule 53 (expression -> CHAR .)
    MINUS           reduce using rule 53 (expression -> CHAR .)
    TIMES           reduce using rule 53 (expression -> CHAR .)
    DIVIDE          reduce using rule 53 (expression -> CHAR .)
    AND             reduce using rule 53 (expression -> CHAR .)
    OR              reduce using rule 53 (expression -> CHAR .)
    LT              reduce using rule 53 (expression -> CHAR .)
    LE              reduce using rule 53 (expression -> CHAR .)
    EQ              reduce using rule 53 (expression -> CHAR .)
    GE              reduce using rule 53 (expression -> CHAR .)
    GT              reduce using rule 53 (expression -> CHAR .)
    )               reduce using rule 53 (expression -> CHAR .)
    ,               reduce using rule 53 (expression -> CHAR .)
    }               reduce using rule 53 (expression -> CHAR .)


state 20

    (54) expression -> TR .

    ;               reduce using rule 54 (expression -> TR .)
    PLUS            reduce using rule 54 (expression -> TR .)
    MINUS           reduce using rule 54 (expression -> TR .)
    TIMES           reduce using rule 54 (expression -> TR .)
    DIVIDE          reduce using rule 54 (expression -> TR .)
    AND             reduce using rule 54 (expression -> TR .)
    OR              reduce using rule 54 (expression -> TR .)
    LT              reduce using rule 54 (expression -> TR .)
    LE              reduce using rule 54 (expression -> TR .)
    EQ              reduce using rule 54 (expression -> TR .)
    GE              reduce using rule 54 (expression -> TR .)
    GT              reduce using rule 54 (expression -> TR .)
    )               reduce using rule 54 (expression -> TR .)
    ,               reduce using rule 54 (expression -> TR .)
    }               reduce using rule 54 (expression -> TR .)


state 21

    (55) expression -> FL .

    ;               reduce using rule 55 (expression -> FL .)
    PLUS            reduce using rule 55 (expression -> FL .)
    MINUS           reduce using rule 55 (expression -> FL .)
    TIMES           reduce using rule 55 (expression -> FL .)
    DIVIDE          reduce using rule 55 (expression -> FL .)
    AND             reduce using rule 55 (expression -> FL .)
    OR              reduce using rule 55 (expression -> FL .)
    LT              reduce using rule 55 (expression -> FL .)
    LE              reduce using rule 55 (expression -> FL .)
    EQ              reduce using rule 55 (expression -> FL .)
    GE              reduce using rule 55 (expression -> FL .)
    GT              reduce using rule 55 (expression -> FL .)
    )               reduce using rule 55 (expression -> FL .)
    ,               reduce using rule 55 (expression -> FL .)
    }               reduce using rule 55 (expression -> FL .)


state 22

    (56) expression -> NULL .

    ;               reduce using rule 56 (expression -> NULL .)
    PLUS            reduce using rule 56 (expression -> NULL .)
    MINUS           reduce using rule 56 (expression -> NULL .)
    TIMES           reduce using rule 56 (expression -> NULL .)
    DIVIDE          reduce using rule 56 (expression -> NULL .)
    AND             reduce using rule 56 (expression -> NULL .)
    OR              reduce using rule 56 (expression -> NULL .)
    LT              reduce using rule 56 (expression -> NULL .)
    LE              reduce using rule 56 (expression -> NULL .)
    EQ              reduce using rule 56 (expression -> NULL .)
    GE              reduce using rule 56 (expression -> NULL .)
    GT              reduce using rule 56 (expression -> NULL .)
    )               reduce using rule 56 (expression -> NULL .)
    ,               reduce using rule 56 (expression -> NULL .)
    }               reduce using rule 56 (expression -> NULL .)


state 23

    (58) expression -> function_call .

    ;               reduce using rule 58 (expression -> function_call .)
    PLUS            reduce using rule 58 (expression -> function_call .)
    MINUS           reduce using rule 58 (expression -> function_call .)
    TIMES           reduce using rule 58 (expression -> function_call .)
    DIVIDE          reduce using rule 58 (expression -> function_call .)
    AND             reduce using rule 58 (expression -> function_call .)
    OR              reduce using rule 58 (expression -> function_call .)
    LT              reduce using rule 58 (expression -> function_call .)
    LE              reduce using rule 58 (expression -> function_call .)
    EQ              reduce using rule 58 (expression -> function_call .)
    GE              reduce using rule 58 (expression -> function_call .)
    GT              reduce using rule 58 (expression -> function_call .)
    )               reduce using rule 58 (expression -> function_call .)
    ,               reduce using rule 58 (expression -> function_call .)
    }               reduce using rule 58 (expression -> function_call .)


state 24

    (59) expression -> object_call .

    ;               reduce using rule 59 (expression -> object_call .)
    PLUS            reduce using rule 59 (expression -> object_call .)
    MINUS           reduce using rule 59 (expression -> object_call .)
    TIMES           reduce using rule 59 (expression -> object_call .)
    DIVIDE          reduce using rule 59 (expression -> object_call .)
    AND             reduce using rule 59 (expression -> object_call .)
    OR              reduce using rule 59 (expression -> object_call .)
    LT              reduce using rule 59 (expression -> object_call .)
    LE              reduce using rule 59 (expression -> object_call .)
    EQ              reduce using rule 59 (expression -> object_call .)
    GE              reduce using rule 59 (expression -> object_call .)
    GT              reduce using rule 59 (expression -> object_call .)
    )               reduce using rule 59 (expression -> object_call .)
    ,               reduce using rule 59 (expression -> object_call .)
    }               reduce using rule 59 (expression -> object_call .)


state 25

    (10) simple_block -> if_conditional .

    LET             reduce using rule 10 (simple_block -> if_conditional .)
    STRING_IMPLICIT reduce using rule 10 (simple_block -> if_conditional .)
    TYPE            reduce using rule 10 (simple_block -> if_conditional .)
    (               reduce using rule 10 (simple_block -> if_conditional .)
    INTEGER         reduce using rule 10 (simple_block -> if_conditional .)
    REAL            reduce using rule 10 (simple_block -> if_conditional .)
    CHAR            reduce using rule 10 (simple_block -> if_conditional .)
    TR              reduce using rule 10 (simple_block -> if_conditional .)
    FL              reduce using rule 10 (simple_block -> if_conditional .)
    NULL            reduce using rule 10 (simple_block -> if_conditional .)
    FUNCTION        reduce using rule 10 (simple_block -> if_conditional .)
    PLUS            reduce using rule 10 (simple_block -> if_conditional .)
    MINUS           reduce using rule 10 (simple_block -> if_conditional .)
    NOT             reduce using rule 10 (simple_block -> if_conditional .)
    {               reduce using rule 10 (simple_block -> if_conditional .)
    IF              reduce using rule 10 (simple_block -> if_conditional .)
    WHILE           reduce using rule 10 (simple_block -> if_conditional .)
    $end            reduce using rule 10 (simple_block -> if_conditional .)
    }               reduce using rule 10 (simple_block -> if_conditional .)
    RETURN          reduce using rule 10 (simple_block -> if_conditional .)


state 26

    (11) simple_block -> while_loop .

    LET             reduce using rule 11 (simple_block -> while_loop .)
    STRING_IMPLICIT reduce using rule 11 (simple_block -> while_loop .)
    TYPE            reduce using rule 11 (simple_block -> while_loop .)
    (               reduce using rule 11 (simple_block -> while_loop .)
    INTEGER         reduce using rule 11 (simple_block -> while_loop .)
    REAL            reduce using rule 11 (simple_block -> while_loop .)
    CHAR            reduce using rule 11 (simple_block -> while_loop .)
    TR              reduce using rule 11 (simple_block -> while_loop .)
    FL              reduce using rule 11 (simple_block -> while_loop .)
    NULL            reduce using rule 11 (simple_block -> while_loop .)
    FUNCTION        reduce using rule 11 (simple_block -> while_loop .)
    PLUS            reduce using rule 11 (simple_block -> while_loop .)
    MINUS           reduce using rule 11 (simple_block -> while_loop .)
    NOT             reduce using rule 11 (simple_block -> while_loop .)
    {               reduce using rule 11 (simple_block -> while_loop .)
    IF              reduce using rule 11 (simple_block -> while_loop .)
    WHILE           reduce using rule 11 (simple_block -> while_loop .)
    $end            reduce using rule 11 (simple_block -> while_loop .)
    }               reduce using rule 11 (simple_block -> while_loop .)
    RETURN          reduce using rule 11 (simple_block -> while_loop .)


state 27

    (43) function -> FUNCTION . STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; }

    STRING_IMPLICIT shift and go to state 65


state 28

    (25) object -> { . object_content }
    (26) object_content -> . object_item , object_content
    (27) object_content -> . object_item
    (28) object_content -> . empty
    (29) object_item -> . key : basic_type
    (30) object_item -> . key : expression
    (85) empty -> .
    (31) key -> . STRING_EXPLICIT
    (32) key -> . STRING_IMPLICIT

    }               reduce using rule 85 (empty -> .)
    STRING_EXPLICIT shift and go to state 70
    STRING_IMPLICIT shift and go to state 71

    object_content                 shift and go to state 66
    object_item                    shift and go to state 67
    empty                          shift and go to state 68
    key                            shift and go to state 69

state 29

    (72) unary_operator -> PLUS .

    (               reduce using rule 72 (unary_operator -> PLUS .)
    INTEGER         reduce using rule 72 (unary_operator -> PLUS .)
    REAL            reduce using rule 72 (unary_operator -> PLUS .)
    CHAR            reduce using rule 72 (unary_operator -> PLUS .)
    TR              reduce using rule 72 (unary_operator -> PLUS .)
    FL              reduce using rule 72 (unary_operator -> PLUS .)
    NULL            reduce using rule 72 (unary_operator -> PLUS .)
    STRING_IMPLICIT reduce using rule 72 (unary_operator -> PLUS .)
    PLUS            reduce using rule 72 (unary_operator -> PLUS .)
    MINUS           reduce using rule 72 (unary_operator -> PLUS .)
    NOT             reduce using rule 72 (unary_operator -> PLUS .)
    {               reduce using rule 72 (unary_operator -> PLUS .)


state 30

    (73) unary_operator -> MINUS .

    (               reduce using rule 73 (unary_operator -> MINUS .)
    INTEGER         reduce using rule 73 (unary_operator -> MINUS .)
    REAL            reduce using rule 73 (unary_operator -> MINUS .)
    CHAR            reduce using rule 73 (unary_operator -> MINUS .)
    TR              reduce using rule 73 (unary_operator -> MINUS .)
    FL              reduce using rule 73 (unary_operator -> MINUS .)
    NULL            reduce using rule 73 (unary_operator -> MINUS .)
    STRING_IMPLICIT reduce using rule 73 (unary_operator -> MINUS .)
    PLUS            reduce using rule 73 (unary_operator -> MINUS .)
    MINUS           reduce using rule 73 (unary_operator -> MINUS .)
    NOT             reduce using rule 73 (unary_operator -> MINUS .)
    {               reduce using rule 73 (unary_operator -> MINUS .)


state 31

    (74) unary_operator -> NOT .

    (               reduce using rule 74 (unary_operator -> NOT .)
    INTEGER         reduce using rule 74 (unary_operator -> NOT .)
    REAL            reduce using rule 74 (unary_operator -> NOT .)
    CHAR            reduce using rule 74 (unary_operator -> NOT .)
    TR              reduce using rule 74 (unary_operator -> NOT .)
    FL              reduce using rule 74 (unary_operator -> NOT .)
    NULL            reduce using rule 74 (unary_operator -> NOT .)
    STRING_IMPLICIT reduce using rule 74 (unary_operator -> NOT .)
    PLUS            reduce using rule 74 (unary_operator -> NOT .)
    MINUS           reduce using rule 74 (unary_operator -> NOT .)
    NOT             reduce using rule 74 (unary_operator -> NOT .)
    {               reduce using rule 74 (unary_operator -> NOT .)


state 32

    (39) if_conditional -> IF . condition block_body
    (40) if_conditional -> IF . condition block_body ELSE block_body
    (42) condition -> . ( expression )

    (               shift and go to state 73

    condition                      shift and go to state 72

state 33

    (41) while_loop -> WHILE . condition block_body
    (42) condition -> . ( expression )

    (               shift and go to state 73

    condition                      shift and go to state 74

state 34

    (1) file -> statement file .

    $end            reduce using rule 1 (file -> statement file .)


state 35

    (2) file -> block file .

    $end            reduce using rule 2 (file -> block file .)


state 36

    (4) statement -> declaration ; .

    LET             reduce using rule 4 (statement -> declaration ; .)
    STRING_IMPLICIT reduce using rule 4 (statement -> declaration ; .)
    TYPE            reduce using rule 4 (statement -> declaration ; .)
    (               reduce using rule 4 (statement -> declaration ; .)
    INTEGER         reduce using rule 4 (statement -> declaration ; .)
    REAL            reduce using rule 4 (statement -> declaration ; .)
    CHAR            reduce using rule 4 (statement -> declaration ; .)
    TR              reduce using rule 4 (statement -> declaration ; .)
    FL              reduce using rule 4 (statement -> declaration ; .)
    NULL            reduce using rule 4 (statement -> declaration ; .)
    FUNCTION        reduce using rule 4 (statement -> declaration ; .)
    PLUS            reduce using rule 4 (statement -> declaration ; .)
    MINUS           reduce using rule 4 (statement -> declaration ; .)
    NOT             reduce using rule 4 (statement -> declaration ; .)
    {               reduce using rule 4 (statement -> declaration ; .)
    IF              reduce using rule 4 (statement -> declaration ; .)
    WHILE           reduce using rule 4 (statement -> declaration ; .)
    $end            reduce using rule 4 (statement -> declaration ; .)
    }               reduce using rule 4 (statement -> declaration ; .)
    RETURN          reduce using rule 4 (statement -> declaration ; .)


state 37

    (22) assignment -> declaration ASSIGN . expression
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 75
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 38

    (5) statement -> assignment ; .

    LET             reduce using rule 5 (statement -> assignment ; .)
    STRING_IMPLICIT reduce using rule 5 (statement -> assignment ; .)
    TYPE            reduce using rule 5 (statement -> assignment ; .)
    (               reduce using rule 5 (statement -> assignment ; .)
    INTEGER         reduce using rule 5 (statement -> assignment ; .)
    REAL            reduce using rule 5 (statement -> assignment ; .)
    CHAR            reduce using rule 5 (statement -> assignment ; .)
    TR              reduce using rule 5 (statement -> assignment ; .)
    FL              reduce using rule 5 (statement -> assignment ; .)
    NULL            reduce using rule 5 (statement -> assignment ; .)
    FUNCTION        reduce using rule 5 (statement -> assignment ; .)
    PLUS            reduce using rule 5 (statement -> assignment ; .)
    MINUS           reduce using rule 5 (statement -> assignment ; .)
    NOT             reduce using rule 5 (statement -> assignment ; .)
    {               reduce using rule 5 (statement -> assignment ; .)
    IF              reduce using rule 5 (statement -> assignment ; .)
    WHILE           reduce using rule 5 (statement -> assignment ; .)
    $end            reduce using rule 5 (statement -> assignment ; .)
    }               reduce using rule 5 (statement -> assignment ; .)
    RETURN          reduce using rule 5 (statement -> assignment ; .)


state 39

    (6) statement -> definition ; .

    LET             reduce using rule 6 (statement -> definition ; .)
    STRING_IMPLICIT reduce using rule 6 (statement -> definition ; .)
    TYPE            reduce using rule 6 (statement -> definition ; .)
    (               reduce using rule 6 (statement -> definition ; .)
    INTEGER         reduce using rule 6 (statement -> definition ; .)
    REAL            reduce using rule 6 (statement -> definition ; .)
    CHAR            reduce using rule 6 (statement -> definition ; .)
    TR              reduce using rule 6 (statement -> definition ; .)
    FL              reduce using rule 6 (statement -> definition ; .)
    NULL            reduce using rule 6 (statement -> definition ; .)
    FUNCTION        reduce using rule 6 (statement -> definition ; .)
    PLUS            reduce using rule 6 (statement -> definition ; .)
    MINUS           reduce using rule 6 (statement -> definition ; .)
    NOT             reduce using rule 6 (statement -> definition ; .)
    {               reduce using rule 6 (statement -> definition ; .)
    IF              reduce using rule 6 (statement -> definition ; .)
    WHILE           reduce using rule 6 (statement -> definition ; .)
    $end            reduce using rule 6 (statement -> definition ; .)
    }               reduce using rule 6 (statement -> definition ; .)
    RETURN          reduce using rule 6 (statement -> definition ; .)


state 40

    (7) statement -> expression ; .

    LET             reduce using rule 7 (statement -> expression ; .)
    STRING_IMPLICIT reduce using rule 7 (statement -> expression ; .)
    TYPE            reduce using rule 7 (statement -> expression ; .)
    (               reduce using rule 7 (statement -> expression ; .)
    INTEGER         reduce using rule 7 (statement -> expression ; .)
    REAL            reduce using rule 7 (statement -> expression ; .)
    CHAR            reduce using rule 7 (statement -> expression ; .)
    TR              reduce using rule 7 (statement -> expression ; .)
    FL              reduce using rule 7 (statement -> expression ; .)
    NULL            reduce using rule 7 (statement -> expression ; .)
    FUNCTION        reduce using rule 7 (statement -> expression ; .)
    PLUS            reduce using rule 7 (statement -> expression ; .)
    MINUS           reduce using rule 7 (statement -> expression ; .)
    NOT             reduce using rule 7 (statement -> expression ; .)
    {               reduce using rule 7 (statement -> expression ; .)
    IF              reduce using rule 7 (statement -> expression ; .)
    WHILE           reduce using rule 7 (statement -> expression ; .)
    $end            reduce using rule 7 (statement -> expression ; .)
    }               reduce using rule 7 (statement -> expression ; .)
    RETURN          reduce using rule 7 (statement -> expression ; .)


state 41

    (49) expression -> expression binary_operator . expression
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 76
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 42

    (61) binary_operator -> PLUS .

    (               reduce using rule 61 (binary_operator -> PLUS .)
    INTEGER         reduce using rule 61 (binary_operator -> PLUS .)
    REAL            reduce using rule 61 (binary_operator -> PLUS .)
    CHAR            reduce using rule 61 (binary_operator -> PLUS .)
    TR              reduce using rule 61 (binary_operator -> PLUS .)
    FL              reduce using rule 61 (binary_operator -> PLUS .)
    NULL            reduce using rule 61 (binary_operator -> PLUS .)
    STRING_IMPLICIT reduce using rule 61 (binary_operator -> PLUS .)
    PLUS            reduce using rule 61 (binary_operator -> PLUS .)
    MINUS           reduce using rule 61 (binary_operator -> PLUS .)
    NOT             reduce using rule 61 (binary_operator -> PLUS .)
    {               reduce using rule 61 (binary_operator -> PLUS .)


state 43

    (62) binary_operator -> MINUS .

    (               reduce using rule 62 (binary_operator -> MINUS .)
    INTEGER         reduce using rule 62 (binary_operator -> MINUS .)
    REAL            reduce using rule 62 (binary_operator -> MINUS .)
    CHAR            reduce using rule 62 (binary_operator -> MINUS .)
    TR              reduce using rule 62 (binary_operator -> MINUS .)
    FL              reduce using rule 62 (binary_operator -> MINUS .)
    NULL            reduce using rule 62 (binary_operator -> MINUS .)
    STRING_IMPLICIT reduce using rule 62 (binary_operator -> MINUS .)
    PLUS            reduce using rule 62 (binary_operator -> MINUS .)
    MINUS           reduce using rule 62 (binary_operator -> MINUS .)
    NOT             reduce using rule 62 (binary_operator -> MINUS .)
    {               reduce using rule 62 (binary_operator -> MINUS .)


state 44

    (63) binary_operator -> TIMES .

    (               reduce using rule 63 (binary_operator -> TIMES .)
    INTEGER         reduce using rule 63 (binary_operator -> TIMES .)
    REAL            reduce using rule 63 (binary_operator -> TIMES .)
    CHAR            reduce using rule 63 (binary_operator -> TIMES .)
    TR              reduce using rule 63 (binary_operator -> TIMES .)
    FL              reduce using rule 63 (binary_operator -> TIMES .)
    NULL            reduce using rule 63 (binary_operator -> TIMES .)
    STRING_IMPLICIT reduce using rule 63 (binary_operator -> TIMES .)
    PLUS            reduce using rule 63 (binary_operator -> TIMES .)
    MINUS           reduce using rule 63 (binary_operator -> TIMES .)
    NOT             reduce using rule 63 (binary_operator -> TIMES .)
    {               reduce using rule 63 (binary_operator -> TIMES .)


state 45

    (64) binary_operator -> DIVIDE .

    (               reduce using rule 64 (binary_operator -> DIVIDE .)
    INTEGER         reduce using rule 64 (binary_operator -> DIVIDE .)
    REAL            reduce using rule 64 (binary_operator -> DIVIDE .)
    CHAR            reduce using rule 64 (binary_operator -> DIVIDE .)
    TR              reduce using rule 64 (binary_operator -> DIVIDE .)
    FL              reduce using rule 64 (binary_operator -> DIVIDE .)
    NULL            reduce using rule 64 (binary_operator -> DIVIDE .)
    STRING_IMPLICIT reduce using rule 64 (binary_operator -> DIVIDE .)
    PLUS            reduce using rule 64 (binary_operator -> DIVIDE .)
    MINUS           reduce using rule 64 (binary_operator -> DIVIDE .)
    NOT             reduce using rule 64 (binary_operator -> DIVIDE .)
    {               reduce using rule 64 (binary_operator -> DIVIDE .)


state 46

    (65) binary_operator -> AND .

    (               reduce using rule 65 (binary_operator -> AND .)
    INTEGER         reduce using rule 65 (binary_operator -> AND .)
    REAL            reduce using rule 65 (binary_operator -> AND .)
    CHAR            reduce using rule 65 (binary_operator -> AND .)
    TR              reduce using rule 65 (binary_operator -> AND .)
    FL              reduce using rule 65 (binary_operator -> AND .)
    NULL            reduce using rule 65 (binary_operator -> AND .)
    STRING_IMPLICIT reduce using rule 65 (binary_operator -> AND .)
    PLUS            reduce using rule 65 (binary_operator -> AND .)
    MINUS           reduce using rule 65 (binary_operator -> AND .)
    NOT             reduce using rule 65 (binary_operator -> AND .)
    {               reduce using rule 65 (binary_operator -> AND .)


state 47

    (66) binary_operator -> OR .

    (               reduce using rule 66 (binary_operator -> OR .)
    INTEGER         reduce using rule 66 (binary_operator -> OR .)
    REAL            reduce using rule 66 (binary_operator -> OR .)
    CHAR            reduce using rule 66 (binary_operator -> OR .)
    TR              reduce using rule 66 (binary_operator -> OR .)
    FL              reduce using rule 66 (binary_operator -> OR .)
    NULL            reduce using rule 66 (binary_operator -> OR .)
    STRING_IMPLICIT reduce using rule 66 (binary_operator -> OR .)
    PLUS            reduce using rule 66 (binary_operator -> OR .)
    MINUS           reduce using rule 66 (binary_operator -> OR .)
    NOT             reduce using rule 66 (binary_operator -> OR .)
    {               reduce using rule 66 (binary_operator -> OR .)


state 48

    (67) binary_operator -> LT .

    (               reduce using rule 67 (binary_operator -> LT .)
    INTEGER         reduce using rule 67 (binary_operator -> LT .)
    REAL            reduce using rule 67 (binary_operator -> LT .)
    CHAR            reduce using rule 67 (binary_operator -> LT .)
    TR              reduce using rule 67 (binary_operator -> LT .)
    FL              reduce using rule 67 (binary_operator -> LT .)
    NULL            reduce using rule 67 (binary_operator -> LT .)
    STRING_IMPLICIT reduce using rule 67 (binary_operator -> LT .)
    PLUS            reduce using rule 67 (binary_operator -> LT .)
    MINUS           reduce using rule 67 (binary_operator -> LT .)
    NOT             reduce using rule 67 (binary_operator -> LT .)
    {               reduce using rule 67 (binary_operator -> LT .)


state 49

    (68) binary_operator -> LE .

    (               reduce using rule 68 (binary_operator -> LE .)
    INTEGER         reduce using rule 68 (binary_operator -> LE .)
    REAL            reduce using rule 68 (binary_operator -> LE .)
    CHAR            reduce using rule 68 (binary_operator -> LE .)
    TR              reduce using rule 68 (binary_operator -> LE .)
    FL              reduce using rule 68 (binary_operator -> LE .)
    NULL            reduce using rule 68 (binary_operator -> LE .)
    STRING_IMPLICIT reduce using rule 68 (binary_operator -> LE .)
    PLUS            reduce using rule 68 (binary_operator -> LE .)
    MINUS           reduce using rule 68 (binary_operator -> LE .)
    NOT             reduce using rule 68 (binary_operator -> LE .)
    {               reduce using rule 68 (binary_operator -> LE .)


state 50

    (69) binary_operator -> EQ .

    (               reduce using rule 69 (binary_operator -> EQ .)
    INTEGER         reduce using rule 69 (binary_operator -> EQ .)
    REAL            reduce using rule 69 (binary_operator -> EQ .)
    CHAR            reduce using rule 69 (binary_operator -> EQ .)
    TR              reduce using rule 69 (binary_operator -> EQ .)
    FL              reduce using rule 69 (binary_operator -> EQ .)
    NULL            reduce using rule 69 (binary_operator -> EQ .)
    STRING_IMPLICIT reduce using rule 69 (binary_operator -> EQ .)
    PLUS            reduce using rule 69 (binary_operator -> EQ .)
    MINUS           reduce using rule 69 (binary_operator -> EQ .)
    NOT             reduce using rule 69 (binary_operator -> EQ .)
    {               reduce using rule 69 (binary_operator -> EQ .)


state 51

    (70) binary_operator -> GE .

    (               reduce using rule 70 (binary_operator -> GE .)
    INTEGER         reduce using rule 70 (binary_operator -> GE .)
    REAL            reduce using rule 70 (binary_operator -> GE .)
    CHAR            reduce using rule 70 (binary_operator -> GE .)
    TR              reduce using rule 70 (binary_operator -> GE .)
    FL              reduce using rule 70 (binary_operator -> GE .)
    NULL            reduce using rule 70 (binary_operator -> GE .)
    STRING_IMPLICIT reduce using rule 70 (binary_operator -> GE .)
    PLUS            reduce using rule 70 (binary_operator -> GE .)
    MINUS           reduce using rule 70 (binary_operator -> GE .)
    NOT             reduce using rule 70 (binary_operator -> GE .)
    {               reduce using rule 70 (binary_operator -> GE .)


state 52

    (71) binary_operator -> GT .

    (               reduce using rule 71 (binary_operator -> GT .)
    INTEGER         reduce using rule 71 (binary_operator -> GT .)
    REAL            reduce using rule 71 (binary_operator -> GT .)
    CHAR            reduce using rule 71 (binary_operator -> GT .)
    TR              reduce using rule 71 (binary_operator -> GT .)
    FL              reduce using rule 71 (binary_operator -> GT .)
    NULL            reduce using rule 71 (binary_operator -> GT .)
    STRING_IMPLICIT reduce using rule 71 (binary_operator -> GT .)
    PLUS            reduce using rule 71 (binary_operator -> GT .)
    MINUS           reduce using rule 71 (binary_operator -> GT .)
    NOT             reduce using rule 71 (binary_operator -> GT .)
    {               reduce using rule 71 (binary_operator -> GT .)


state 53

    (17) declaration -> LET declaration_content .

    ;               reduce using rule 17 (declaration -> LET declaration_content .)
    ASSIGN          reduce using rule 17 (declaration -> LET declaration_content .)


state 54

    (18) declaration_content -> item . , declaration_content
    (19) declaration_content -> item .

    ,               shift and go to state 77
    ;               reduce using rule 19 (declaration_content -> item .)
    ASSIGN          reduce using rule 19 (declaration_content -> item .)


state 55

    (20) item -> STRING_IMPLICIT . : STRING_IMPLICIT
    (21) item -> STRING_IMPLICIT .

    :               shift and go to state 78
    ,               reduce using rule 21 (item -> STRING_IMPLICIT .)
    ;               reduce using rule 21 (item -> STRING_IMPLICIT .)
    ASSIGN          reduce using rule 21 (item -> STRING_IMPLICIT .)


state 56

    (23) assignment -> STRING_IMPLICIT ASSIGN . expression
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 79
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 57

    (75) function_call -> STRING_IMPLICIT ( . function_call_list )
    (76) function_call_list -> . function_call_list_nonempty
    (77) function_call_list -> . empty
    (78) function_call_list_nonempty -> . expression , function_call_list_nonempty
    (79) function_call_list_nonempty -> . expression
    (85) empty -> .
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    )               reduce using rule 85 (empty -> .)
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    function_call_list             shift and go to state 80
    function_call_list_nonempty    shift and go to state 81
    empty                          shift and go to state 82
    expression                     shift and go to state 83
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 58

    (80) object_call -> STRING_IMPLICIT object_attribute_list .

    ;               reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    PLUS            reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    MINUS           reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    TIMES           reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    DIVIDE          reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    AND             reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    OR              reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    LT              reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    LE              reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    EQ              reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    GE              reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    GT              reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    )               reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    ,               reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)
    }               reduce using rule 80 (object_call -> STRING_IMPLICIT object_attribute_list .)


state 59

    (81) object_attribute_list -> [ . STRING_EXPLICIT ] object_attribute_list
    (83) object_attribute_list -> [ . STRING_EXPLICIT ]

    STRING_EXPLICIT shift and go to state 84


state 60

    (82) object_attribute_list -> . . STRING_IMPLICIT object_attribute_list
    (84) object_attribute_list -> . . STRING_IMPLICIT

    STRING_IMPLICIT shift and go to state 85


state 61

    (24) definition -> TYPE STRING_IMPLICIT . ASSIGN object

    ASSIGN          shift and go to state 86


state 62

    (48) expression -> ( expression . )
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    )               shift and go to state 87
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 63

    (57) expression -> STRING_IMPLICIT .
    (75) function_call -> STRING_IMPLICIT . ( function_call_list )
    (80) object_call -> STRING_IMPLICIT . object_attribute_list
    (81) object_attribute_list -> . [ STRING_EXPLICIT ] object_attribute_list
    (82) object_attribute_list -> . . STRING_IMPLICIT object_attribute_list
    (83) object_attribute_list -> . [ STRING_EXPLICIT ]
    (84) object_attribute_list -> . . STRING_IMPLICIT

    )               reduce using rule 57 (expression -> STRING_IMPLICIT .)
    PLUS            reduce using rule 57 (expression -> STRING_IMPLICIT .)
    MINUS           reduce using rule 57 (expression -> STRING_IMPLICIT .)
    TIMES           reduce using rule 57 (expression -> STRING_IMPLICIT .)
    DIVIDE          reduce using rule 57 (expression -> STRING_IMPLICIT .)
    AND             reduce using rule 57 (expression -> STRING_IMPLICIT .)
    OR              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    LT              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    LE              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    EQ              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    GE              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    GT              reduce using rule 57 (expression -> STRING_IMPLICIT .)
    ;               reduce using rule 57 (expression -> STRING_IMPLICIT .)
    ,               reduce using rule 57 (expression -> STRING_IMPLICIT .)
    }               reduce using rule 57 (expression -> STRING_IMPLICIT .)
    (               shift and go to state 57
    [               shift and go to state 59
    .               shift and go to state 60

    object_attribute_list          shift and go to state 58

state 64

    (50) expression -> unary_operator expression .
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ;               reduce using rule 50 (expression -> unary_operator expression .)
    PLUS            reduce using rule 50 (expression -> unary_operator expression .)
    MINUS           reduce using rule 50 (expression -> unary_operator expression .)
    TIMES           reduce using rule 50 (expression -> unary_operator expression .)
    DIVIDE          reduce using rule 50 (expression -> unary_operator expression .)
    AND             reduce using rule 50 (expression -> unary_operator expression .)
    OR              reduce using rule 50 (expression -> unary_operator expression .)
    LT              reduce using rule 50 (expression -> unary_operator expression .)
    LE              reduce using rule 50 (expression -> unary_operator expression .)
    EQ              reduce using rule 50 (expression -> unary_operator expression .)
    GE              reduce using rule 50 (expression -> unary_operator expression .)
    GT              reduce using rule 50 (expression -> unary_operator expression .)
    )               reduce using rule 50 (expression -> unary_operator expression .)
    ,               reduce using rule 50 (expression -> unary_operator expression .)
    }               reduce using rule 50 (expression -> unary_operator expression .)

  ! PLUS            [ shift and go to state 42 ]
  ! MINUS           [ shift and go to state 43 ]
  ! TIMES           [ shift and go to state 44 ]
  ! DIVIDE          [ shift and go to state 45 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! LE              [ shift and go to state 49 ]
  ! EQ              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]

    binary_operator                shift and go to state 41

state 65

    (43) function -> FUNCTION STRING_IMPLICIT . ( argument_list ) : type { block_body_code RETURN expression ; }

    (               shift and go to state 88


state 66

    (25) object -> { object_content . }

    }               shift and go to state 89


state 67

    (26) object_content -> object_item . , object_content
    (27) object_content -> object_item .

    ,               shift and go to state 90
    }               reduce using rule 27 (object_content -> object_item .)


state 68

    (28) object_content -> empty .

    }               reduce using rule 28 (object_content -> empty .)


state 69

    (29) object_item -> key . : basic_type
    (30) object_item -> key . : expression

    :               shift and go to state 91


state 70

    (31) key -> STRING_EXPLICIT .

    :               reduce using rule 31 (key -> STRING_EXPLICIT .)


state 71

    (32) key -> STRING_IMPLICIT .

    :               reduce using rule 32 (key -> STRING_IMPLICIT .)


state 72

    (39) if_conditional -> IF condition . block_body
    (40) if_conditional -> IF condition . block_body ELSE block_body
    (12) block_body -> . { block_body_code }

    {               shift and go to state 93

    block_body                     shift and go to state 92

state 73

    (42) condition -> ( . expression )
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 94
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 74

    (41) while_loop -> WHILE condition . block_body
    (12) block_body -> . { block_body_code }

    {               shift and go to state 93

    block_body                     shift and go to state 95

state 75

    (22) assignment -> declaration ASSIGN expression .
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ;               reduce using rule 22 (assignment -> declaration ASSIGN expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 76

    (49) expression -> expression binary_operator expression .
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ;               reduce using rule 49 (expression -> expression binary_operator expression .)
    PLUS            reduce using rule 49 (expression -> expression binary_operator expression .)
    MINUS           reduce using rule 49 (expression -> expression binary_operator expression .)
    AND             reduce using rule 49 (expression -> expression binary_operator expression .)
    OR              reduce using rule 49 (expression -> expression binary_operator expression .)
    LT              reduce using rule 49 (expression -> expression binary_operator expression .)
    LE              reduce using rule 49 (expression -> expression binary_operator expression .)
    EQ              reduce using rule 49 (expression -> expression binary_operator expression .)
    GE              reduce using rule 49 (expression -> expression binary_operator expression .)
    GT              reduce using rule 49 (expression -> expression binary_operator expression .)
    )               reduce using rule 49 (expression -> expression binary_operator expression .)
    ,               reduce using rule 49 (expression -> expression binary_operator expression .)
    }               reduce using rule 49 (expression -> expression binary_operator expression .)
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45

  ! TIMES           [ reduce using rule 49 (expression -> expression binary_operator expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> expression binary_operator expression .) ]
  ! PLUS            [ shift and go to state 42 ]
  ! MINUS           [ shift and go to state 43 ]
  ! AND             [ shift and go to state 46 ]
  ! OR              [ shift and go to state 47 ]
  ! LT              [ shift and go to state 48 ]
  ! LE              [ shift and go to state 49 ]
  ! EQ              [ shift and go to state 50 ]
  ! GE              [ shift and go to state 51 ]
  ! GT              [ shift and go to state 52 ]

    binary_operator                shift and go to state 41

state 77

    (18) declaration_content -> item , . declaration_content
    (18) declaration_content -> . item , declaration_content
    (19) declaration_content -> . item
    (20) item -> . STRING_IMPLICIT : STRING_IMPLICIT
    (21) item -> . STRING_IMPLICIT

    STRING_IMPLICIT shift and go to state 55

    item                           shift and go to state 54
    declaration_content            shift and go to state 96

state 78

    (20) item -> STRING_IMPLICIT : . STRING_IMPLICIT

    STRING_IMPLICIT shift and go to state 97


state 79

    (23) assignment -> STRING_IMPLICIT ASSIGN expression .
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ;               reduce using rule 23 (assignment -> STRING_IMPLICIT ASSIGN expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 80

    (75) function_call -> STRING_IMPLICIT ( function_call_list . )

    )               shift and go to state 98


state 81

    (76) function_call_list -> function_call_list_nonempty .

    )               reduce using rule 76 (function_call_list -> function_call_list_nonempty .)


state 82

    (77) function_call_list -> empty .

    )               reduce using rule 77 (function_call_list -> empty .)


state 83

    (78) function_call_list_nonempty -> expression . , function_call_list_nonempty
    (79) function_call_list_nonempty -> expression .
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ,               shift and go to state 99
    )               reduce using rule 79 (function_call_list_nonempty -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 84

    (81) object_attribute_list -> [ STRING_EXPLICIT . ] object_attribute_list
    (83) object_attribute_list -> [ STRING_EXPLICIT . ]

    ]               shift and go to state 100


state 85

    (82) object_attribute_list -> . STRING_IMPLICIT . object_attribute_list
    (84) object_attribute_list -> . STRING_IMPLICIT .
    (81) object_attribute_list -> . [ STRING_EXPLICIT ] object_attribute_list
    (82) object_attribute_list -> . . STRING_IMPLICIT object_attribute_list
    (83) object_attribute_list -> . [ STRING_EXPLICIT ]
    (84) object_attribute_list -> . . STRING_IMPLICIT

    ;               reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    PLUS            reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    MINUS           reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    TIMES           reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    DIVIDE          reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    AND             reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    OR              reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    LT              reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    LE              reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    EQ              reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    GE              reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    GT              reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    )               reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    ,               reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    }               reduce using rule 84 (object_attribute_list -> . STRING_IMPLICIT .)
    [               shift and go to state 59
    .               shift and go to state 60

    object_attribute_list          shift and go to state 101

state 86

    (24) definition -> TYPE STRING_IMPLICIT ASSIGN . object
    (25) object -> . { object_content }

    {               shift and go to state 28

    object                         shift and go to state 102

state 87

    (48) expression -> ( expression ) .

    ;               reduce using rule 48 (expression -> ( expression ) .)
    PLUS            reduce using rule 48 (expression -> ( expression ) .)
    MINUS           reduce using rule 48 (expression -> ( expression ) .)
    TIMES           reduce using rule 48 (expression -> ( expression ) .)
    DIVIDE          reduce using rule 48 (expression -> ( expression ) .)
    AND             reduce using rule 48 (expression -> ( expression ) .)
    OR              reduce using rule 48 (expression -> ( expression ) .)
    LT              reduce using rule 48 (expression -> ( expression ) .)
    LE              reduce using rule 48 (expression -> ( expression ) .)
    EQ              reduce using rule 48 (expression -> ( expression ) .)
    GE              reduce using rule 48 (expression -> ( expression ) .)
    GT              reduce using rule 48 (expression -> ( expression ) .)
    )               reduce using rule 48 (expression -> ( expression ) .)
    ,               reduce using rule 48 (expression -> ( expression ) .)
    }               reduce using rule 48 (expression -> ( expression ) .)


state 88

    (43) function -> FUNCTION STRING_IMPLICIT ( . argument_list ) : type { block_body_code RETURN expression ; }
    (44) argument_list -> . argument_list_nonempty
    (45) argument_list -> . empty
    (46) argument_list_nonempty -> . STRING_IMPLICIT : type , argument_list_nonempty
    (47) argument_list_nonempty -> . STRING_IMPLICIT : type
    (85) empty -> .

    STRING_IMPLICIT shift and go to state 103
    )               reduce using rule 85 (empty -> .)

    argument_list                  shift and go to state 104
    argument_list_nonempty         shift and go to state 105
    empty                          shift and go to state 106

state 89

    (25) object -> { object_content } .

    ;               reduce using rule 25 (object -> { object_content } .)
    PLUS            reduce using rule 25 (object -> { object_content } .)
    MINUS           reduce using rule 25 (object -> { object_content } .)
    TIMES           reduce using rule 25 (object -> { object_content } .)
    DIVIDE          reduce using rule 25 (object -> { object_content } .)
    AND             reduce using rule 25 (object -> { object_content } .)
    OR              reduce using rule 25 (object -> { object_content } .)
    LT              reduce using rule 25 (object -> { object_content } .)
    LE              reduce using rule 25 (object -> { object_content } .)
    EQ              reduce using rule 25 (object -> { object_content } .)
    GE              reduce using rule 25 (object -> { object_content } .)
    GT              reduce using rule 25 (object -> { object_content } .)
    )               reduce using rule 25 (object -> { object_content } .)
    ,               reduce using rule 25 (object -> { object_content } .)
    }               reduce using rule 25 (object -> { object_content } .)


state 90

    (26) object_content -> object_item , . object_content
    (26) object_content -> . object_item , object_content
    (27) object_content -> . object_item
    (28) object_content -> . empty
    (29) object_item -> . key : basic_type
    (30) object_item -> . key : expression
    (85) empty -> .
    (31) key -> . STRING_EXPLICIT
    (32) key -> . STRING_IMPLICIT

    }               reduce using rule 85 (empty -> .)
    STRING_EXPLICIT shift and go to state 70
    STRING_IMPLICIT shift and go to state 71

    object_item                    shift and go to state 67
    object_content                 shift and go to state 107
    empty                          shift and go to state 68
    key                            shift and go to state 69

state 91

    (29) object_item -> key : . basic_type
    (30) object_item -> key : . expression
    (35) basic_type -> . INT
    (36) basic_type -> . FLOAT
    (37) basic_type -> . CHARACTER
    (38) basic_type -> . BOOLEAN
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    INT             shift and go to state 110
    FLOAT           shift and go to state 111
    CHARACTER       shift and go to state 112
    BOOLEAN         shift and go to state 113
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    basic_type                     shift and go to state 108
    expression                     shift and go to state 109
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 92

    (39) if_conditional -> IF condition block_body .
    (40) if_conditional -> IF condition block_body . ELSE block_body

    LET             reduce using rule 39 (if_conditional -> IF condition block_body .)
    STRING_IMPLICIT reduce using rule 39 (if_conditional -> IF condition block_body .)
    TYPE            reduce using rule 39 (if_conditional -> IF condition block_body .)
    (               reduce using rule 39 (if_conditional -> IF condition block_body .)
    INTEGER         reduce using rule 39 (if_conditional -> IF condition block_body .)
    REAL            reduce using rule 39 (if_conditional -> IF condition block_body .)
    CHAR            reduce using rule 39 (if_conditional -> IF condition block_body .)
    TR              reduce using rule 39 (if_conditional -> IF condition block_body .)
    FL              reduce using rule 39 (if_conditional -> IF condition block_body .)
    NULL            reduce using rule 39 (if_conditional -> IF condition block_body .)
    FUNCTION        reduce using rule 39 (if_conditional -> IF condition block_body .)
    PLUS            reduce using rule 39 (if_conditional -> IF condition block_body .)
    MINUS           reduce using rule 39 (if_conditional -> IF condition block_body .)
    NOT             reduce using rule 39 (if_conditional -> IF condition block_body .)
    {               reduce using rule 39 (if_conditional -> IF condition block_body .)
    IF              reduce using rule 39 (if_conditional -> IF condition block_body .)
    WHILE           reduce using rule 39 (if_conditional -> IF condition block_body .)
    $end            reduce using rule 39 (if_conditional -> IF condition block_body .)
    }               reduce using rule 39 (if_conditional -> IF condition block_body .)
    RETURN          reduce using rule 39 (if_conditional -> IF condition block_body .)
    ELSE            shift and go to state 114


state 93

    (12) block_body -> { . block_body_code }
    (13) block_body_code -> . statement block_body_code
    (14) block_body_code -> . simple_block block_body_code
    (15) block_body_code -> . statement
    (16) block_body_code -> . simple_block
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    block_body_code                shift and go to state 115
    statement                      shift and go to state 116
    simple_block                   shift and go to state 117
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    expression                     shift and go to state 8
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24

state 94

    (42) condition -> ( expression . )
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    )               shift and go to state 118
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 95

    (41) while_loop -> WHILE condition block_body .

    LET             reduce using rule 41 (while_loop -> WHILE condition block_body .)
    STRING_IMPLICIT reduce using rule 41 (while_loop -> WHILE condition block_body .)
    TYPE            reduce using rule 41 (while_loop -> WHILE condition block_body .)
    (               reduce using rule 41 (while_loop -> WHILE condition block_body .)
    INTEGER         reduce using rule 41 (while_loop -> WHILE condition block_body .)
    REAL            reduce using rule 41 (while_loop -> WHILE condition block_body .)
    CHAR            reduce using rule 41 (while_loop -> WHILE condition block_body .)
    TR              reduce using rule 41 (while_loop -> WHILE condition block_body .)
    FL              reduce using rule 41 (while_loop -> WHILE condition block_body .)
    NULL            reduce using rule 41 (while_loop -> WHILE condition block_body .)
    FUNCTION        reduce using rule 41 (while_loop -> WHILE condition block_body .)
    PLUS            reduce using rule 41 (while_loop -> WHILE condition block_body .)
    MINUS           reduce using rule 41 (while_loop -> WHILE condition block_body .)
    NOT             reduce using rule 41 (while_loop -> WHILE condition block_body .)
    {               reduce using rule 41 (while_loop -> WHILE condition block_body .)
    IF              reduce using rule 41 (while_loop -> WHILE condition block_body .)
    WHILE           reduce using rule 41 (while_loop -> WHILE condition block_body .)
    $end            reduce using rule 41 (while_loop -> WHILE condition block_body .)
    }               reduce using rule 41 (while_loop -> WHILE condition block_body .)
    RETURN          reduce using rule 41 (while_loop -> WHILE condition block_body .)


state 96

    (18) declaration_content -> item , declaration_content .

    ;               reduce using rule 18 (declaration_content -> item , declaration_content .)
    ASSIGN          reduce using rule 18 (declaration_content -> item , declaration_content .)


state 97

    (20) item -> STRING_IMPLICIT : STRING_IMPLICIT .

    ,               reduce using rule 20 (item -> STRING_IMPLICIT : STRING_IMPLICIT .)
    ;               reduce using rule 20 (item -> STRING_IMPLICIT : STRING_IMPLICIT .)
    ASSIGN          reduce using rule 20 (item -> STRING_IMPLICIT : STRING_IMPLICIT .)


state 98

    (75) function_call -> STRING_IMPLICIT ( function_call_list ) .

    ;               reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    PLUS            reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    MINUS           reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    TIMES           reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    DIVIDE          reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    AND             reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    OR              reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    LT              reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    LE              reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    EQ              reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    GE              reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    GT              reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    )               reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    ,               reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)
    }               reduce using rule 75 (function_call -> STRING_IMPLICIT ( function_call_list ) .)


state 99

    (78) function_call_list_nonempty -> expression , . function_call_list_nonempty
    (78) function_call_list_nonempty -> . expression , function_call_list_nonempty
    (79) function_call_list_nonempty -> . expression
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 83
    function_call_list_nonempty    shift and go to state 119
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 100

    (81) object_attribute_list -> [ STRING_EXPLICIT ] . object_attribute_list
    (83) object_attribute_list -> [ STRING_EXPLICIT ] .
    (81) object_attribute_list -> . [ STRING_EXPLICIT ] object_attribute_list
    (82) object_attribute_list -> . . STRING_IMPLICIT object_attribute_list
    (83) object_attribute_list -> . [ STRING_EXPLICIT ]
    (84) object_attribute_list -> . . STRING_IMPLICIT

    ;               reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    PLUS            reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    MINUS           reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    TIMES           reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    DIVIDE          reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    AND             reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    OR              reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    LT              reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    LE              reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    EQ              reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    GE              reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    GT              reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    )               reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    ,               reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    }               reduce using rule 83 (object_attribute_list -> [ STRING_EXPLICIT ] .)
    [               shift and go to state 59
    .               shift and go to state 60

    object_attribute_list          shift and go to state 120

state 101

    (82) object_attribute_list -> . STRING_IMPLICIT object_attribute_list .

    ;               reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    PLUS            reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    MINUS           reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    TIMES           reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    DIVIDE          reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    AND             reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    OR              reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    LT              reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    LE              reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    EQ              reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    GE              reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    GT              reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    )               reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    ,               reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)
    }               reduce using rule 82 (object_attribute_list -> . STRING_IMPLICIT object_attribute_list .)


state 102

    (24) definition -> TYPE STRING_IMPLICIT ASSIGN object .

    ;               reduce using rule 24 (definition -> TYPE STRING_IMPLICIT ASSIGN object .)


state 103

    (46) argument_list_nonempty -> STRING_IMPLICIT . : type , argument_list_nonempty
    (47) argument_list_nonempty -> STRING_IMPLICIT . : type

    :               shift and go to state 121


state 104

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list . ) : type { block_body_code RETURN expression ; }

    )               shift and go to state 122


state 105

    (44) argument_list -> argument_list_nonempty .

    )               reduce using rule 44 (argument_list -> argument_list_nonempty .)


state 106

    (45) argument_list -> empty .

    )               reduce using rule 45 (argument_list -> empty .)


state 107

    (26) object_content -> object_item , object_content .

    }               reduce using rule 26 (object_content -> object_item , object_content .)


state 108

    (29) object_item -> key : basic_type .

    ,               reduce using rule 29 (object_item -> key : basic_type .)
    }               reduce using rule 29 (object_item -> key : basic_type .)


state 109

    (30) object_item -> key : expression .
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ,               reduce using rule 30 (object_item -> key : expression .)
    }               reduce using rule 30 (object_item -> key : expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 110

    (35) basic_type -> INT .

    ,               reduce using rule 35 (basic_type -> INT .)
    }               reduce using rule 35 (basic_type -> INT .)
    )               reduce using rule 35 (basic_type -> INT .)
    {               reduce using rule 35 (basic_type -> INT .)


state 111

    (36) basic_type -> FLOAT .

    ,               reduce using rule 36 (basic_type -> FLOAT .)
    }               reduce using rule 36 (basic_type -> FLOAT .)
    )               reduce using rule 36 (basic_type -> FLOAT .)
    {               reduce using rule 36 (basic_type -> FLOAT .)


state 112

    (37) basic_type -> CHARACTER .

    ,               reduce using rule 37 (basic_type -> CHARACTER .)
    }               reduce using rule 37 (basic_type -> CHARACTER .)
    )               reduce using rule 37 (basic_type -> CHARACTER .)
    {               reduce using rule 37 (basic_type -> CHARACTER .)


state 113

    (38) basic_type -> BOOLEAN .

    ,               reduce using rule 38 (basic_type -> BOOLEAN .)
    }               reduce using rule 38 (basic_type -> BOOLEAN .)
    )               reduce using rule 38 (basic_type -> BOOLEAN .)
    {               reduce using rule 38 (basic_type -> BOOLEAN .)


state 114

    (40) if_conditional -> IF condition block_body ELSE . block_body
    (12) block_body -> . { block_body_code }

    {               shift and go to state 93

    block_body                     shift and go to state 123

state 115

    (12) block_body -> { block_body_code . }

    }               shift and go to state 124


state 116

    (13) block_body_code -> statement . block_body_code
    (15) block_body_code -> statement .
    (13) block_body_code -> . statement block_body_code
    (14) block_body_code -> . simple_block block_body_code
    (15) block_body_code -> . statement
    (16) block_body_code -> . simple_block
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    }               reduce using rule 15 (block_body_code -> statement .)
    RETURN          reduce using rule 15 (block_body_code -> statement .)
    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    statement                      shift and go to state 116
    block_body_code                shift and go to state 125
    simple_block                   shift and go to state 117
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    expression                     shift and go to state 8
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24

state 117

    (14) block_body_code -> simple_block . block_body_code
    (16) block_body_code -> simple_block .
    (13) block_body_code -> . statement block_body_code
    (14) block_body_code -> . simple_block block_body_code
    (15) block_body_code -> . statement
    (16) block_body_code -> . simple_block
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    }               reduce using rule 16 (block_body_code -> simple_block .)
    RETURN          reduce using rule 16 (block_body_code -> simple_block .)
    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    simple_block                   shift and go to state 117
    block_body_code                shift and go to state 126
    statement                      shift and go to state 116
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    expression                     shift and go to state 8
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24

state 118

    (42) condition -> ( expression ) .

    {               reduce using rule 42 (condition -> ( expression ) .)


state 119

    (78) function_call_list_nonempty -> expression , function_call_list_nonempty .

    )               reduce using rule 78 (function_call_list_nonempty -> expression , function_call_list_nonempty .)


state 120

    (81) object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .

    ;               reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    PLUS            reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    MINUS           reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    TIMES           reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    DIVIDE          reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    AND             reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    OR              reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    LT              reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    LE              reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    EQ              reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    GE              reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    GT              reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    )               reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    ,               reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)
    }               reduce using rule 81 (object_attribute_list -> [ STRING_EXPLICIT ] object_attribute_list .)


state 121

    (46) argument_list_nonempty -> STRING_IMPLICIT : . type , argument_list_nonempty
    (47) argument_list_nonempty -> STRING_IMPLICIT : . type
    (33) type -> . basic_type
    (34) type -> . STRING_IMPLICIT
    (35) basic_type -> . INT
    (36) basic_type -> . FLOAT
    (37) basic_type -> . CHARACTER
    (38) basic_type -> . BOOLEAN

    STRING_IMPLICIT shift and go to state 127
    INT             shift and go to state 110
    FLOAT           shift and go to state 111
    CHARACTER       shift and go to state 112
    BOOLEAN         shift and go to state 113

    type                           shift and go to state 128
    basic_type                     shift and go to state 129

state 122

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) . : type { block_body_code RETURN expression ; }

    :               shift and go to state 130


state 123

    (40) if_conditional -> IF condition block_body ELSE block_body .

    LET             reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    STRING_IMPLICIT reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    TYPE            reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    (               reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    INTEGER         reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    REAL            reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    CHAR            reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    TR              reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    FL              reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    NULL            reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    FUNCTION        reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    PLUS            reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    MINUS           reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    NOT             reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    {               reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    IF              reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    WHILE           reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    $end            reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    }               reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)
    RETURN          reduce using rule 40 (if_conditional -> IF condition block_body ELSE block_body .)


state 124

    (12) block_body -> { block_body_code } .

    ELSE            reduce using rule 12 (block_body -> { block_body_code } .)
    LET             reduce using rule 12 (block_body -> { block_body_code } .)
    STRING_IMPLICIT reduce using rule 12 (block_body -> { block_body_code } .)
    TYPE            reduce using rule 12 (block_body -> { block_body_code } .)
    (               reduce using rule 12 (block_body -> { block_body_code } .)
    INTEGER         reduce using rule 12 (block_body -> { block_body_code } .)
    REAL            reduce using rule 12 (block_body -> { block_body_code } .)
    CHAR            reduce using rule 12 (block_body -> { block_body_code } .)
    TR              reduce using rule 12 (block_body -> { block_body_code } .)
    FL              reduce using rule 12 (block_body -> { block_body_code } .)
    NULL            reduce using rule 12 (block_body -> { block_body_code } .)
    FUNCTION        reduce using rule 12 (block_body -> { block_body_code } .)
    PLUS            reduce using rule 12 (block_body -> { block_body_code } .)
    MINUS           reduce using rule 12 (block_body -> { block_body_code } .)
    NOT             reduce using rule 12 (block_body -> { block_body_code } .)
    {               reduce using rule 12 (block_body -> { block_body_code } .)
    IF              reduce using rule 12 (block_body -> { block_body_code } .)
    WHILE           reduce using rule 12 (block_body -> { block_body_code } .)
    $end            reduce using rule 12 (block_body -> { block_body_code } .)
    }               reduce using rule 12 (block_body -> { block_body_code } .)
    RETURN          reduce using rule 12 (block_body -> { block_body_code } .)


state 125

    (13) block_body_code -> statement block_body_code .

    }               reduce using rule 13 (block_body_code -> statement block_body_code .)
    RETURN          reduce using rule 13 (block_body_code -> statement block_body_code .)


state 126

    (14) block_body_code -> simple_block block_body_code .

    }               reduce using rule 14 (block_body_code -> simple_block block_body_code .)
    RETURN          reduce using rule 14 (block_body_code -> simple_block block_body_code .)


state 127

    (34) type -> STRING_IMPLICIT .

    ,               reduce using rule 34 (type -> STRING_IMPLICIT .)
    )               reduce using rule 34 (type -> STRING_IMPLICIT .)
    {               reduce using rule 34 (type -> STRING_IMPLICIT .)


state 128

    (46) argument_list_nonempty -> STRING_IMPLICIT : type . , argument_list_nonempty
    (47) argument_list_nonempty -> STRING_IMPLICIT : type .

    ,               shift and go to state 131
    )               reduce using rule 47 (argument_list_nonempty -> STRING_IMPLICIT : type .)


state 129

    (33) type -> basic_type .

    ,               reduce using rule 33 (type -> basic_type .)
    )               reduce using rule 33 (type -> basic_type .)
    {               reduce using rule 33 (type -> basic_type .)


state 130

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : . type { block_body_code RETURN expression ; }
    (33) type -> . basic_type
    (34) type -> . STRING_IMPLICIT
    (35) basic_type -> . INT
    (36) basic_type -> . FLOAT
    (37) basic_type -> . CHARACTER
    (38) basic_type -> . BOOLEAN

    STRING_IMPLICIT shift and go to state 127
    INT             shift and go to state 110
    FLOAT           shift and go to state 111
    CHARACTER       shift and go to state 112
    BOOLEAN         shift and go to state 113

    type                           shift and go to state 132
    basic_type                     shift and go to state 129

state 131

    (46) argument_list_nonempty -> STRING_IMPLICIT : type , . argument_list_nonempty
    (46) argument_list_nonempty -> . STRING_IMPLICIT : type , argument_list_nonempty
    (47) argument_list_nonempty -> . STRING_IMPLICIT : type

    STRING_IMPLICIT shift and go to state 103

    argument_list_nonempty         shift and go to state 133

state 132

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type . { block_body_code RETURN expression ; }

    {               shift and go to state 134


state 133

    (46) argument_list_nonempty -> STRING_IMPLICIT : type , argument_list_nonempty .

    )               reduce using rule 46 (argument_list_nonempty -> STRING_IMPLICIT : type , argument_list_nonempty .)


state 134

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { . block_body_code RETURN expression ; }
    (13) block_body_code -> . statement block_body_code
    (14) block_body_code -> . simple_block block_body_code
    (15) block_body_code -> . statement
    (16) block_body_code -> . simple_block
    (4) statement -> . declaration ;
    (5) statement -> . assignment ;
    (6) statement -> . definition ;
    (7) statement -> . expression ;
    (10) simple_block -> . if_conditional
    (11) simple_block -> . while_loop
    (17) declaration -> . LET declaration_content
    (22) assignment -> . declaration ASSIGN expression
    (23) assignment -> . STRING_IMPLICIT ASSIGN expression
    (24) definition -> . TYPE STRING_IMPLICIT ASSIGN object
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (39) if_conditional -> . IF condition block_body
    (40) if_conditional -> . IF condition block_body ELSE block_body
    (41) while_loop -> . WHILE condition block_body
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    LET             shift and go to state 11
    STRING_IMPLICIT shift and go to state 12
    TYPE            shift and go to state 13
    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    IF              shift and go to state 32
    WHILE           shift and go to state 33
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    block_body_code                shift and go to state 135
    expression                     shift and go to state 8
    statement                      shift and go to state 116
    simple_block                   shift and go to state 117
    declaration                    shift and go to state 5
    assignment                     shift and go to state 6
    definition                     shift and go to state 7
    if_conditional                 shift and go to state 25
    while_loop                     shift and go to state 26
    object                         shift and go to state 14
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24

state 135

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code . RETURN expression ; }

    RETURN          shift and go to state 136


state 136

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN . expression ; }
    (48) expression -> . ( expression )
    (49) expression -> . expression binary_operator expression
    (50) expression -> . unary_operator expression
    (51) expression -> . INTEGER
    (52) expression -> . REAL
    (53) expression -> . CHAR
    (54) expression -> . TR
    (55) expression -> . FL
    (56) expression -> . NULL
    (57) expression -> . STRING_IMPLICIT
    (58) expression -> . function_call
    (59) expression -> . object_call
    (60) expression -> . object
    (72) unary_operator -> . PLUS
    (73) unary_operator -> . MINUS
    (74) unary_operator -> . NOT
    (75) function_call -> . STRING_IMPLICIT ( function_call_list )
    (80) object_call -> . STRING_IMPLICIT object_attribute_list
    (25) object -> . { object_content }

    (               shift and go to state 15
    INTEGER         shift and go to state 17
    REAL            shift and go to state 18
    CHAR            shift and go to state 19
    TR              shift and go to state 20
    FL              shift and go to state 21
    NULL            shift and go to state 22
    STRING_IMPLICIT shift and go to state 63
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    NOT             shift and go to state 31
    {               shift and go to state 28

    expression                     shift and go to state 137
    unary_operator                 shift and go to state 16
    function_call                  shift and go to state 23
    object_call                    shift and go to state 24
    object                         shift and go to state 14

state 137

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression . ; }
    (49) expression -> expression . binary_operator expression
    (61) binary_operator -> . PLUS
    (62) binary_operator -> . MINUS
    (63) binary_operator -> . TIMES
    (64) binary_operator -> . DIVIDE
    (65) binary_operator -> . AND
    (66) binary_operator -> . OR
    (67) binary_operator -> . LT
    (68) binary_operator -> . LE
    (69) binary_operator -> . EQ
    (70) binary_operator -> . GE
    (71) binary_operator -> . GT

    ;               shift and go to state 138
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    AND             shift and go to state 46
    OR              shift and go to state 47
    LT              shift and go to state 48
    LE              shift and go to state 49
    EQ              shift and go to state 50
    GE              shift and go to state 51
    GT              shift and go to state 52

    binary_operator                shift and go to state 41

state 138

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; . }

    }               shift and go to state 139


state 139

    (43) function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .

    LET             reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    STRING_IMPLICIT reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    TYPE            reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    (               reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    INTEGER         reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    REAL            reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    CHAR            reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    TR              reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    FL              reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    NULL            reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    FUNCTION        reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    PLUS            reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    MINUS           reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    NOT             reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    {               reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    IF              reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    WHILE           reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)
    $end            reduce using rule 43 (function -> FUNCTION STRING_IMPLICIT ( argument_list ) : type { block_body_code RETURN expression ; } .)

